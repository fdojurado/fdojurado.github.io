<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.542">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fernando Jurado-Lasso - Publications</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HWZYWK2SD5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-HWZYWK2SD5', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="cv.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Fernando Jurado-Lasso</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./publications.html" aria-current="page"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/fdojurado"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:ffjla@dtu.dk"> <i class="bi bi-envelope-at-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preprints-2" id="toc-preprints-2" class="nav-link active" data-scroll-target="#preprints-2">Preprints (2)</a></li>
  <li><a href="#journal-articles-5" id="toc-journal-articles-5" class="nav-link" data-scroll-target="#journal-articles-5">Journal Articles (5)</a></li>
  <li><a href="#conference-papers-1" id="toc-conference-papers-1" class="nav-link" data-scroll-target="#conference-papers-1">Conference Papers (1)</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Publications</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>My research output consists of <strong>8</strong> publications in <strong>5</strong> different sources, including <strong>5</strong> journals, <strong>1</strong> conferences, and <strong>2</strong> preprints. I am first author in <strong>0</strong> of them.</p>
<h2 id="preprints-2" class="anchored">Preprints (2)</h2>
1,9,5,2 (2024). HRL-TSCH: A Hierarchical Reinforcement Learning-based TSCH Scheduler for IIoT. <em>arXiv</em>. <a href="http://arxiv.org/abs/2401.10368" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
The Industrial Internet of Things (IIoT) demands adaptable Networked Embedded Systems (NES) for optimal performance. Combined with recent advances in Artificial Intelligence (AI), tailored solutions can be developed to meet specific application requirements. This study introduces HRL-TSCH, an approach rooted in Hierarchical Reinforcement Learning (HRL), to devise Time Slotted Channel Hopping (TSCH) schedules provisioning IIoT demand. HRL-TSCH employs dual policies: one at a higher level for TSCH schedule link management, and another at a lower level for timeslot and channel assignments. The proposed RL agents address a multi-objective problem, optimizing throughput, power efficiency, and network delay based on predefined application requirements. Simulation experiments demonstrate HRL-TSCH superiority over existing state-of-art approaches, effectively achieving an optimal balance between throughput, power consumption, and delay, thereby enhancing IIoT network performance.
</p>
<p>
<b>Keywords:</b> Industrial Internet of Things (IIoT); Networked Embedded Systems (NES); Sleep Scheduling; Time Slotted Channel Hopping (TSCH); Reinforcement Learning (RL); Software-Defined Wireless Sensor Networks (SDWSNs)
</p>
</details>
1,5,2 (2024). A Centralized Reinforcement Learning Framework for Adaptive Clustering with Low Control Overhead in IoT Networks. <em>arXiv</em>. <a href="http://arxiv.org/abs/2401.15767" target="_blank">[*rxiv]</a> <a href="https://github.com/fdojurado/PyNetSim.git" target="_blank">[code]</a>
<details>
<summary>
Abstract
</summary>
<p>
Wireless Sensor Networks (WSNs) play a pivotal role in enabling Internet of Things (IoT) devices with sensing and actuation capabilities. Operating in remote and resource-constrained environments, these IoT devices face challenges related to energy consumption, crucial for network longevity. Clustering protocols have emerged as an effective solution to alleviate energy burdens on IoT devices. This paper introduces Low-Energy Adaptive Clustering Hierarchy with Reinforcement Learning-based Controller (LEACH-RLC), a novel clustering protocol that employs a Mixed Integer Linear Programming (MILP) for strategic selection of cluster heads (CHs) and node-to-cluster assignments. Additionally, it integrates a Reinforcement Learning (RL) agent to minimize control overhead by learning optimal timings for generating new clusters. Addressing key research questions, LEACH-RLC seeks to balance control overhead reduction without compromising overall network performance. Through extensive simulations, this paper investigates the frequency and opportune moments for generating new clustering solutions. Results demonstrate the superior performance of LEACH-RLC over conventional LEACH and LEACH-C, showcasing enhanced network lifetime, reduced average energy consumption, and minimized control overhead. The proposed protocol contributes to advancing the efficiency and adaptability of WSNs, addressing critical challenges in IoT deployments.
</p>
<p>
<b>Keywords:</b> Internet of Things (IoT); Clustering Protocols; Reinforcement Learning (RL); Control Overhead; Low-Energy Adaptive Clustering Hierarchy (LEACH)
</p>
</details>
<h2 id="journal-articles-5" class="anchored">Journal Articles (5)</h2>
1,8,5,2 (2023). ELISE: A Reinforcement Learning Framework to Optimize the Slotframe Size of the TSCH Protocol in IoT Networks. <em>IEEE Systems Journal</em>. <a href="https://doi.org/10.1109/JSYST.2024.3371429" target="_blank">[pdf]</a> <a href="https://doi.org/10.36227/techrxiv.23212442.v3" target="_blank">[*rxiv]</a> <a href="https://github.com/fdojurado/SDWSN-controller.git" target="_blank">[code]</a> <a href="https://fdojurado.github.io/SDWSN-controller/elise/" target="_blank">[slides]</a> <a href="http://sdwsn-controller.readthedocs.io/" target="_blank">[doc]</a>
<details>
<summary>
Abstract
</summary>
<p>
The Internet of Things is shaping the next generation of cyber–physical systems to improve the future industry for smart cities. It has created novel and essential applications that require specific network performance to enhance the quality of services. Since network performance requirements are application-oriented, it is of paramount importance to provide tailored solutions that seamlessly manage the network resources and orchestrate the network to satisfy user requirements. In this article, we propose ELISE, a reinforcement learning (RL) framework to optimize the slotframe size of the time slotted channel hopping protocol in IIoT networks while considering the user requirements. We primarily address the problem of designing a framework that self-adapts to the optimal slotframe length that best suits the user’s requirements. The framework takes care of all functionalities involved in the correct functioning of the network, while the RL agent instructs the framework with a set of actions to determine the optimal slotframe size each time the user requirements change. We evaluate the performance of ELISE through extensive analysis based on simulations and experimental evaluations on a testbed to demonstrate the efficiency of the proposed approach in adapting network resources at runtime to satisfy user requirements.
</p>
<p>
<b>Keywords:</b> Industrial Internet of Things (IIoT); Wireless Sensor Networks (WSNs); Network Management; Reinforcement Learning (RL); Time Slotted Channel Hopping (TSCH)
</p>
</details>
1,10,5,7,2 (2022). A survey on machine learning software-defined wireless sensor networks (ML-SDWSNS): Current status and major challenges. <em>IEEE Access</em>, vol.&nbsp;10, pp.&nbsp;23560-23592. <a href="https://doi.org/10.1109/ACCESS.2022.3153521" target="_blank">[pdf]</a> <a href="https://doi.org/10.36227/techrxiv.16777618.v3" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
Wireless Sensor Network (WSN), which are enablers of the Internet of Things (IoT) technology, are typically used en-masse in widely physically distributed applications to monitor the dynamic conditions of the environment. They collect raw sensor data that is processed centralised. With the current traditional techniques of state-of-art WSN programmed for specific tasks, it is hard to react to any dynamic change in the conditions of the environment beyond the scope of the intended task. To solve this problem, a synergy between Software-Defined Networking (SDN) and WSN has been proposed. This paper aims to present the current status of Software-Defined Wireless Sensor Network (SDWSN) proposals and introduce the readers to the emerging research topic that combines Machine Learning (ML) and SDWSN concepts, also called ML-SDWSNs. ML-SDWSN grants an intelligent, centralised and resource-aware architecture to achieve improved network performance and solve the challenges currently found in the practical implementation of SDWSNs. This survey provides helpful information and insights to the scientific and industrial communities, and professional organisations interested in SDWSN, mainly the current state-of-art, ML techniques, and open issues
</p>
<p>
<b>Keywords:</b> Wireless sensor networks (WSNs); Internet of Things (IoT); Machine Learning (ML); software-defined wireless sensor networks (SDWSNs); Machine Learning Software-Defined Wireless Sensor Networks (ML-SDWSNs)
</p>
</details>
1,6,4,3 (2021). Energy-aware routing for software-defined multihop wireless sensor networks. <em>IEEE Sensors Journal</em>, vol.&nbsp;21(8), pp.&nbsp;10174-10182. <a href="https://doi.org/10.1109/JSEN.2021.3059789" target="_blank">[pdf]</a> <a href="https://doi.org/energy-aware.pdf" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
In this paper, we propose an energy-aware routing algorithm and a control overhead reduction technique for prolonging the network lifetime of software-defined multihop wireless sensor networks (SDWSNs). This is an effort to optimize the energy consumption of WSNs that provide services to the Industrial Internet of Things (IIoT). A centralized controller grants a global view of the sensor network by introducing extra control overhead in the network, but this leads to extra energy costs. However, our new algorithm takes advantage of this global view and balances the network energy by selecting paths with the highest remaining energy level among multiple paths for each sensor node. We also identify key functions draining energy from the SDWSN and minimize their impact by implementing a data packet aggregation function, and minimizing the control overhead by keeping track of the sensor nodes’ routing tables using a simple checksum function. We show that the proposed approach prolongs the network lifetime of the WSN by 6.5% on average compared to the standard shortest-path algorithm, and that the control overhead is reduced by approximately 12% while still maintaining a very high packet delivery ratio.
</p>
<p>
<b>Keywords:</b> Centralized routing; Industrial Internet of Things; network lifetime; software defined wireless sensor networks; software-defined routing; wireless sensor networks
</p>
</details>
1,6,3 (2019). Performance analysis of software-defined multihop wireless sensor networks. <em>IEEE Systems Journal</em>, vol.&nbsp;14(4), pp.&nbsp;4653-4662. <a href="https://doi.org/10.1109/JSYST.2019.2948203" target="_blank">[pdf]</a> <a href="https://doi.org/performance-analysis.pdf" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
In this article, we propose a model-based characterization of energy consumption in a software-defined wireless sensor network (SD-WSN) architecture in an effort to examine the implications for network performance when making the WSN reprogrammable. The proposed model consists of breaking down all key functions involved in the correct functioning of an SD-WSN, namely; neighbor discovery, neighbor advertisement, network configuration, and data collection. The model is analyzed from a multihop network perspective. We consider two static SD-WSN scenarios to examine scalability, and one scenario to assess the performance implications in a pseudo-dynamic SD-WSN. Extensive simulation results are presented regarding the control overhead introduced, the percentage of alive nodes and remaining energy, and the impacts on network lifetime. We show that the accumulated control overhead is inversely proportional to the interaction period with the controller, whereas the remaining energy and the network lifetime are directly proportional to this parameter. Results show that the control overhead, for static SD-WSNs, can take up to 10%-29% of the total data flowing to the controller for the large SD-WSN and 6-19% for the small SD-WSN. For a pseudo-dynamic network, the control overhead can take up to two-thirds of the total data sent to the controller, and the network lifetime was reduced by up to 80% compared with the static scenarios.
</p>
<p>
<b>Keywords:</b> Control overhead; energy consumption; Internet of Things (IoT); software-defined wireless sensor networks (SD-WSNs); wireless sensor networks (WSNs)
</p>
</details>
1,6,3 (2019). A software-defined management system for IP-enabled WSNs. <em>IEEE Systems Journal</em>, vol.&nbsp;14(2), pp.&nbsp;2335-2346. <a href="https://doi.org/10.1109/JSYST.2019.2946781" target="_blank">[pdf]</a> <a href="https://doi.org/sdn-ip-enabled.pdf" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
Software-defined networking (SDN) offers potential pathways to overcome the management complexity of the Internet of Things (IoT). Previous studies have often been limited to software simulations or general proposals only. In this article, we design and evaluate an SDN-based management system for wireless sensor networks (WSNs) using IPv6 over low-power wireless personal area networks (6LoWPAN). The framework is described in detail covering different data-, control-, and application-plane implementations, and includes a novel addressing scheme and packet format. It also uses a centralized routing protocol, located at the SDN controller, based on the shortest path algorithm. We compare our approach with the routing protocol for low-power and lossy networks (RPL), which uses a distributed routing protocol. Hardware tests were carried out in a dynamic environment, with multiple sources of interference for different payload sizes to evaluate the impacts and practicality of SDN in WSNs. The performance comparison shows that the proposed SDN management system for IP-enabled WSNs using a centralized routing protocol outperforms the RPL protocol in terms of round-trip time, jitter, memory consumption, and packet loss rate (PLR), despite the control overhead introduced.
</p>
<p>
<b>Keywords:</b> Internet of Things (IoT); software-defined networks; task management; topology management; wireless sensor networks (WSNs); WSN management
</p>
</details>
<h2 id="conference-papers-1" class="anchored">Conference Papers (1)</h2>
1,6,3 (2018). A software-defined networking framework for IoT based on 6LoWPAN. <em>Proceeding of Wireless Telecommunications Symposium (WTS)</em>. <a href="https://doi.org/10.1109/WTS.2018.8363938" target="_blank">[pdf]</a> <a href="https://doi.org/SD-WSN6Lo.pdf" target="_blank">[*rxiv]</a>
<details>
<summary>
Abstract
</summary>
<p>
The software defined networking framework facilitates flexible and reliable internet of things networks by moving the network intelligence to a centralized location while enabling low power wireless network in the edge. In this paper, we present SD-WSN6Lo, a novel software-defined wireless management solution for 6LoWPAN networks that aims to reduce the management complexity in WSN’s. As an example of the technique, a simulation of controlling the power consumption of sensor nodes is presented. The results demonstrate improved energy consumption of approximately 15% on average per node compared to the baseline condition.
</p>
<p>
<b>Keywords:</b> Wireless sensor networks (WSNs); Internet of Things (IoT); software-defined networking (SDN); 6LoWPAN
</p>
</details>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>